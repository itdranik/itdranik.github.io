---
_edit_last: "2"
_last_editor_used_jetpack: block-editor
_thumbnail_id: "1733"
_wpas_done_all: "1"
author: yauheni.shybeka
topics:
  - coding-interview
cover:
  alt: caching-feature-image
  image: /wp-content/uploads/2020/03/caching-feature-image.png
date: "2020-03-22T19:15:19+00:00"
guid: https://itdranik.com/?p=1047
language:
  - English
parent_post_id: null
post_id: "1047"
post_translations:
  - pll_5e4809c57cc17
tags:
  - c#
  - кэшаванне
  - структуры-дадзеных
title: 'Папулярныя алгарытмы кэшавання: LRU кэш'
url: /be/caching-lru-algorithm-be/

---
Прывітанне, паважаны чытач!

Тэхнічнае сумоўе \- гэта працэс рашэння цікавых алгарытмічных задач, якія хутчэй за ўсё не спатрэбяцца ні табе, ні твайму інтэрв'юеру ў прафесійнай кар'еры, акрамя як на наступным тэхнічным сумоўі. І тым не менш такія задачы вельмі папулярныя на сумоўях, таму што дазваляюць ацаніць навыкі кандыдата ў пошуку абмежаванняў, прасачыць за яго працэсам абдумвання, а таксама замерыць хуткасць набору цыклаў **for** у нататніку. Адным з тыпаў папулярных задач з'яўляюцца задачы на рэалізацыю кэша.

**Кэш** \- гэта праграмнае або апаратнае сховішча дадзеных з высакахуткасным доступам. Кэш часта ўжываецца, напрыклад, для захавання вынікаў вылічэнняў, каб паменшыць колькасць паўторных вылічэнняў. Таксама кэш можа прымяняцца для захавання вынікаў доступу да якога-небудзь сховішча з меншай хуткасцю доступу. У любым выпадку, паколькі кэш толькі дублюе нейкія дадзеныя або вынікі, якія могуць быць атрыманы паўторна, то, як правіла, кэш валодае толькі часовай памяццю. Хай і не такой часовай, як у таго самага рэкрутара, які абяцаў ператэлефанаваць, але не ператэлефанаваў.

Звычайна інтэрфейс кэша можна прадставіць у выглядзе наступнага набору аперацый:

1. Дадаць элемент па ключы;
1. Атрымаць элемент па ключы;
1. Выдаліць элемент па ключы;
1. Ачысціць кэш.

Пры гэтым паколькі дадаваць элементы ў кэш бясконца мы можам толькі ў тэорыі, то кэш павінен таксама апісваць стратэгію выцяснення элементаў. Напрыклад, вызначаць элемент, які павінен быць выдалены пры перавышэнні максімальнай колькасці элементаў.

**LRU (least recently used)** \- стратэгія выцяснення элемента, які не выкарыстоўваўся даўжэй за ўсё. Пад дадзеным элементам разумеецца элемент, доступ да якога па ключы (метады дадання і атрымання значэння) не ажыццяўляўся даўжэй за ўсё.

Поўную рэалізацыю LRU кэша на C#, як заўсёды, можна паглядзець на [GitHub](https://github.com/itdranik/coding-interview/) праекта coding-interview.

Пачнём з рэалізацыі самага простага варыянту без стратэгіі выцяснення. Іншымі словамі дададзім абгортку вакол стандартнай рэалізацыі асацыятыўнага масіва, якая звычайна прысутнічае ў стандартнай бібліятэцы [тваей любімай мовы праграмавання](https://wiki.theory.org/index.php/YourLanguageSucks):

Зараз абмяжуем наш кэш максімальна дазволенай колькасцю элементаў `capacity`. створым агульны лічыльнік доступу да элементаў `totalAccessSteps`, які будзем павялічваць пры кожным наступным доступе. Таксама будзем захоўваць для кожнага захаванага элемента час доступу да яго `accessStepsByKey`, неабходнае для вызначэння элемента, які не выкарыстоўваўся даўжэй за ўсё. Забягаючы наперад адзначым, што дадзеная рэалізацыя не з'яўляецца аптымальнай, у працэсе яна будзе палепшана.

Абнавім самыя відавочныя аперацыі выдалення і ачысткі кэша:

Разгледзім аперацыю дадання элемента ў кэш. У залежнасці ад сітуацыі могуць узнікнуць тры наступных выпадку:

1. Калі дадзены элемент прысутнічае ў кэшы, то абнаўляем яго значэнне і час доступу;
1. Калі кэш утрымлівае менш элементаў, чым яго ёмістасць, то проста захоўваем новы элемент;
1. Калі кэш ўтрымлівае ўжо максімальна дазволеную колькасць элементаў, то выдаляем элемент, які не выкарыстоўваўся даўжэй за ўсё і захоўваем новы элемент.

Заўважым, што абнаўленне значэння элемента ў дадзеным выпадку будзе эквівалентна выдаленню элемента і даданню новага элемента з тым жа ключом, таму што мы ўсё роўна мяняем час доступу. Адкуль атрымліваем наступную рэалізацыю дадання элемента:

Аперацыя доступу да элемента па ключы таксама павінна памяняць час доступу да элемента, таму скарыстаемся ўжо рэалізаваным `Update` метадам:

Як адзначалася вышэй, такая рэалізацыя не з'яўляецца аптымальнай, што адразу заўважае інтэрв'юер і яхідна паведамляе пра тое, што ў кніжках напісана па-іншаму. Асноўная праблема знаходзіцца ў метадзе `Evict`, дзе мы поўным пераборам шукаем элемент з самым раннім часам доступу. Ну што ж, чаму б не заняцца тады аптымізацыяй?

Паколькі нашы аперацыі з кэшам выклікаюцца паслядоўна, то мы можам упарадкаваць усе нашы элементы ў выглядзе спісу ў парадку дадання ад больш ранняга да больш позняга (злева запісаны ключ, а справа \- значэнне):

{{< figure src="/wp-content/uploads/2020/03/lru-cache-original.png" alt="Элементы LRU кэша" caption="Элементы LRU кэша" >}}

Паглядзім, як будзе змяняцца спіс пад уздзеяннем розных аперацый. **Аперацыі ачысткі кэша і выдаленні пэўнага элемента відавочныя**. Таму разгледзім астатнія аперацыі (далей чырвоным колерам будзем паказваць выдаленне вяршыні, а сінім \- даданне):

- **Аперацыя дадання новага элемента, калі кэш утрымлівае менш элементаў, чым максімальна дазволенае значэнне**. У дадзеным выпадку дадаецца новы элемент у канец спісу, бо яго час дадання будзе ў любым выпадку большы, чым час доступу да любога іншага элемента:

{{< figure src="/wp-content/uploads/2020/03/lru-cache-add-new-1.png" alt="Даданне элемента ў LRU кэш" caption="Даданне элемента ў LRU кэш" >}}

- **Аперацыя дадання новага элемента, калі кэш змяшчае максімальна дазволеную колькасць элементаў**. У дадзеным выпадку выдаляецца элемент, які знаходзіцца ў спісе першым, бо час доступу да яго меншы, чым час доступу да любога іншага элемента. Пасля выдалення мы атрымліваем спіс, у якім колькасць элементаў меншая, чым максімальна дазволеная. А значыць слушна тое, што апісана ў пункце вышэй:

{{< figure src="/wp-content/uploads/2020/03/lru-cache-add-new-exceeded-1.png" alt="Даданне элемента ў перапоўнены LRU кэш" caption="Даданне элемента ў перапоўнены LRU кэш" >}}

- **Аперацыя абнаўлення існуючага элемента і аперацыя атрымання значэння па ключы**. Абодва выпадкі эквівалентныя выдаленню элемента і даданню яго ў канец спісу. Новае значэнне элемента можа быць любым (у прыкладзе ніжэй мы пакінулі зыходнае значэнне), таму што не ўплывае на сартаванне элементаў:

{{< figure src="/wp-content/uploads/2020/03/lru-cache-update-1.png" alt="Абнаўленне элемента ў LRU кэшы" caption="Абнаўленне элемента ў LRU кэшы" >}}

Засталося навучыцца хутка знаходзіць элемент у спісе па ключы. Для гэтага будзем захоўваць для кожнага ключа спасылку на патрэбны элемент спісу:

Перапішам метады ачысткі і выдалення элемента з кэша:

Метады дадання элемента (заўважым, што рэалізацыя асноўнага метаду `Add` засталася ранейшай):

І метад атрымання элемента (рэалізацыя метаду `TryGet` амаль не змянілася):

Вось і ўсё, наш кэш гатовы! Можна смела ісці на сумоўе, а мне пара развітвацца. Да сустрэчы!
